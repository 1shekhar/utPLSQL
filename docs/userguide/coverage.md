# Coverage
utPLSQL comes with build-in coverage reporting engine. The code coverage reporting is based on DBMS_PROFILER package provided with Oracle database. 
Code coverage is gathered for the following source types:
* package bodies
* type bodies
* triggers
* procedures
* functions

**Note**

> The package specifications and type specifications are explicitly excluded from code coverage analysis.This limitation is introduced to avoid false-negatives. Most of the package specifications don't contain executable code. The only exception is initialization of global constants and variables in package specification.Since, most of package specifications are not executable at all, there is no information available on the number of lines covered and those would eb reported as 0% covered, which is not desired.

To obtain information about code coverage of your Unit Tests, all you need to do is run your unit tests with one of build-in code coverage reporters.
Following code coverage reporters are supplied with utPLSQL:
* `ut_coverage_html_reporter` - generates a HTML coverage report providing summary and detailed information on code coverage. The html reporter is based on open-source [simplecov-html](https://github.com/colszowka/simplecov-html) reporter for Ruby. It includes source code of the code that was covered (if possible)  
* `ut_coveralls_reporter` - generates a [Coveralls compatible JSON](https://coveralls.zendesk.com/hc/en-us/articles/201774865-API-Introduction) coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like [coveralls](https://coveralls.io) 
* `ut_coverage_sonar_reporter`  - generates a [Sonar Compatible XML](https://docs.sonarqube.org/display/SONAR/Generic+Test+Data) coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like [sonarqube/sonarcloud](https://about.sonarcloud.io/)
* `ut_coverage_cobertura_reporter`  - generates a basic cobertura coverage (http://cobertura.sourceforge.net/xml/coverage-04.dtd) report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like TFS, Jenkins. Please see example of XML generated by java : https://raw.githubusercontent.com/jenkinsci/cobertura-plugin/master/src/test/resources/hudson/plugins/cobertura/coverage-with-data.xml

## Security model
Code coverage is using DBMS_PROFILER to gather information about execution of code under test and therefore follows the [DBMS_PROFILER's Security Model](https://docs.oracle.com/database/121/ARPLS/d_profil.htm#ARPLS67465)
In order to be able to gather coverage information, user executing unit tests needs to be either:
* Owner of the code that is tested
* Have the following privileges to be able to gather coverage on code owned by other users:
    * `create any procedure` system privilege
    * `execute` privilege on the code that is tested (not only the unit tests) or `execute any procedure` system privilege
    
If you have `execute` privilege on the code that are tested, but do not have `create any procedure` system privilege, the code that is tested will be reported as not covered (coverage = 0%).
If you have `execute` privilege only on the unit tests, but do not have `execute` privilege on the code that is tested, the code will not be reported by coverage - as if it did not exist in the database.
If the code that is testes is complied as NATIVE, the code coverage will not be reported as well.

## Running unite tests with coverage
Using code coverage functionality is as easy as using any other [reporter](reporters.md) for utPLSQL project. All you need to do is run your tests from your preferred SQL tool and save the outcomes of reporter to a file.
All you need to do, is pass the constructor of the reporter to your `ut.run`

Example:
```sql
begin
  ut.run(ut_coverage_html_reporter());
end;
/
```
Executes all unit tests in current schema, gather information about code coverage and output the html text into DBMS_OUTPUT.
The `ut_coverage_html_reporter` will produce a interactive HTML report. You may see a sample of code coverage for utPLSQL project [here](https://utplsql.github.io/utPLSQL-coverage-html/)

The report provides a summary information with list of source code that was expected to be covered.

![Coverage Summary page](../images/coverage_html_summary.png)

The report allow to navigate to every source and inspect line by line coverage.

![Coverage Details page](../images/coverage_html_details.png)


### Coverage reporting options

There are two distinct ways to gather code coverage.
- Coverage on database schema/schemes
- Coverage on project files

Those two options are mutually exclusive and cannot be mixed. 
By default, when using one of coverage reporters, coverage is gathered on schema/schemes.

The parameters used to execute tests determine if utPLSQL will be using one approach or the other.

The database schema/schemes containing the tests that were executed during the run, will be reported by coverage reporter.

**Note**

> Regardless of options provided, all unit test packages are excluded from the coverage report. Coverage reports provide information only about the test**ed** code.

The default behavior of coverage reporting can be altered using invocation parameters.

### Coverage on schema

To simply gather coverage for all objects in your current schema execute tests with coverage reporting.

```sql
exec ut.run(ut_coverage_html_reporter());
```

**Note**

> When no filters are used, the size of the coverage report will depend two factors:
> - type of report (does the report include source-code or not)
> - size of source-code the database schema
>
>Keep in mind that for large schema it will take quite some time to produce the coverage report.

#### Setting coverage schema/schemes

By default, coverage is gathered on schema/schemes derived from suite paths provided used to execute tests.
This is correct, as long as your test packages and tested code share the same schema.

So when you run:
```sql
exec ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter());
```
Coverage will be gathered on both `user_1` and `user_2` objects.

If your tests live in a different schema than the tested code you may override the default behavior by providing explicit list of coverage schema names.

In the below example, coverage will still be gathered for `user_1` and `user_2` objects, even thought we run tests located in schema `unit_test_schema`

```sql
exec ut.run('unit_test_schema', ut_coverage_html_reporter(), a_coverage_schemes => ut_varchar2_list('user_1','user_2') );
```

#### Filtering objects in coverage reports

There are two options that can be used to narrow down the scope of coverage report:
- `a_include_objects` - list of `[object_owner.].object_name` to be included in coverage report
- `a_exclude_objects` - list of `[object_owner.].object_name` to be excluded from coverage report

You may specify both include and exclude objects lists to gein more control oner what needs to be included / excluded from coverage reprot.

The object owner is optional in the object list.
If you do not provide object owner, the include/exclude list will be considered for every schema used for coverage gathering (as described above).


Example Limiting coverage by object name, for tested code existing in the same schema as unit tests.
```sql
exec ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), a_include_objects=>ut_varchar2_list('award_bonus'));
```
Executes all tests in schemes: `user_1` and `user_2`. Coverage will only be reported on objects `user_1.award_bonus`, `user_2.award_bonus`


Example: Limiting coverage by object name, for tested code existing in different schemes than unit tests.
```sql
begin
  ut.run(
    'unit_test_schema', ut_coverage_html_reporter(),
     a_coverage_schemes => ut_varchar2_list('user_1','user_2'), 
     a_include_objects => ut_varchar2_list('award_bonus', 'betwnstr')
  );
end;
```
Executes all tests in schema `unit_test_schema`. Coverage will only be reported on objects `user_1.award_bonus`, `user_2.award_bonus`, `user_1.betwnstr`, `user_2.betwnstr`.
Objects that do not exist in database but were specified in `a_include_objects` will get ignored.      

Example: Limiting coverage by object owner and name.
```sql
begin
  ut.run(
    'unit_test_schema', ut_coverage_html_reporter(),
     a_include_objects => ut_varchar2_list('user_1.award_bonus','user_2.betwnstr')
  );
end;
```
Executes all tests in schema `unit_test_schema`. Coverage will only be reported on objects `user_1.award_bonus`, `user_2.betwnstr`

The `a_exclude_objects` can be used in the same way as `a_include_objects`.

Example: Excluding objects from coverage report by providing list of object owner/name to be excluded.
```sql
exec ut.run('unit_test_schema.test_award_bonus', ut_coverage_html_reporter(), a_exclude_objects=>ut_varchar2_list('ut3_user.betwnstr'));
```
Executes test `test_award_bonus` in schema `unit_test_schema`. Coverage will be reported on all objects in schema `ut3_user` except `betwnstr` object.

**Note**
> Filtering using `a_include_objects` and `a_exclude_objects` is only applicable when gathering coverage for schema. Those filters are not applied when reporting coverage on project files.
 
**Note**
> When running coverage on schema objects. All source-code of package bodies, functions, procedures, type-bodies and triggers that were not executed will be reported as having 0% code coverage and all source code lines will show as uncovered.
> This is different than the behavior when gathering coverage on project files. 

### Project-based Coverage

utPLSQL provides reporters that produce reports consumable by external tools like `Sonar`/`SonarCloud`, `Coveralls`.

Services like Sonar, Coveralls and others perform analysis based on source-code in project files.
They are abstracted from database, schema names, packages, procedures and functions and operate on a more generic concept of project source code.

To be able to effectively use reporters dedicated for those tools, utPLSQL provides functionality for mapping database object names to project files.

There are few significant differences when running coverage on project files compared to running coverage on schema/schemes. 
- Coverage is only reported on objects that were successfully mapped to project files
- Project files (database object) that were not executed at all are not reported as fully not covered. It is up to consumer (Sonar/Coveralls) to determine if project file should be considered as 0% coverage or just ignored

In order to successfully use coverage on project files, those files must be mapped to database objects.

Though you can gather project-based code coverage directly using `exec ut.run(...)`, it is highly recommended to use [utPLSQL-cli](https://github.com/utPLSQL/utPLSQL-cli) command line client.

The below examples are using utPLSQL-cli to execute tests and gather coverage information.

##### File mapping using default parameters

Below example illustrates directory structure supported by default parameters of utPLSQL. 
The structure represents a multi-schema project with file-names indicating object owner. 
```
C:
  \my_project
    \sources
      \hr.manage_employees.pks
      \hr.manage_employees.pkb
      \hr.employee_typ.tps
      \hr.employee_typ.tpb
      \hotel.manage_rooms.pks
      \hotel.manage_rooms.pkb
    \tests
      \hr.test_manage_employees.pks
      \hr.test_manage_employees.pkb
      \hotel.test_manage_rooms.pks
      \hotel.test_manage_rooms.pkb
``` 

By default, utPLSQL will convert file-paths into database objects using following regular expression `/((\w+)\.)?(\w+)\.(\w{3})$`
- object owner (if it is present) is identified by expression in second bracket  
- object name is identified by expression in third bracket
- object type is identified by expression in second in fourth bracket


**Note**
> utPLSQL will replace any '\' with '/' for the purpose of mapping files to objects. The paths shown in results will remain (contain '\' where it was present). 
> This is done to simplify the syntax of regular expressions. Regular expression will always use '/' as a directory separator on a file path regardless if you're on Windows or Unix system.    

```bash
utplsql run user/pass@db_url \
 -source_path=source -test_path=tests \
 -f=ut_coverage_html_reporter -o=coverage.html \
 -f=ut_sonar_test_reporter -o=test_results.xml
```  

Considering the above directory structure the command will:
- run all tests for user `user`
- map database code to project files in `sources` directory and save code coverage results into `coverage.html`
- map test packages to project files in `tests` directory and save test results into `test_results.xml` 

To better understand the default regular expression used, have a look [here](https://regex101.com/r/4qP6Aj/3).

##### Using custom regular expression

If your project directory structure is different, you can use additional configuration parameters to tell utPLSQL how the project files are to be mapped into database objects.  

Example: Using custom regular-expression on multi-schema project with separate directories for each object owner.
```
C:
  \my_project
    \sources
      \hr
        \manage_employees.pks
        \manage_employees.pkb
        \employee_typ.tps
        \employee_typ.tpb
      \hotel
        \manage_rooms.pks
        \manage_rooms.pkb
    \tests
      \hr
        \test_manage_employees.pks
        \test_manage_employees.pkb
      \hotel
        \test_manage_rooms.pks
        \test_manage_rooms.pkb
```

The below command will gather coverage and map files to database objects using custom regular expression.
The owner/name/type subexpressions do not need to be explicitly specified if they are same as default values ( 2/3/4 ).
We have specified them explicitly here to illustrate the syntax.
```bash
utplsql run user/pass@db_url \
 -source_path=source \
 -regex_expression="/((\w+)/)?(\w+)\.(\w{3})$" \
 -owner_subexpression=2 \
 -name_subexpression=3 \
 -type_subexpression=4 \
 -test_path=tests -regex_expression="/((\w+)/)?(\w+)\.(\w{3})$" \
 -f=ut_coverage_html_reporter -o=coverage.html \
 -f=ut_sonar_test_reporter -o=test_results.xml
```  

You can specify different mapping rules for source files and for test files - see [utPLSQL-cli readme](https://github.com/utPLSQL/utPLSQL-cli) for details.

To better understand the regular expression used, have a look [here](https://regex101.com/r/0lk0rV/1/).
 
##### Explicitly specifying object owner

When dealing with projects that operate within single schema the project structure probably not indicate the owner.
In such scenarios, you can explicitly specify the object owner for both tests and source code.

Example: Single-schema project - no indication of object owner
```
C:
  \my_project
    \sources
      \manage_employees.pks
      \manage_employees.pkb
    \tests
      \test_manage_employees.pks
      \test_manage_employees.pkb
```

The below command will gather coverage and map files to database objects.
For the database objects mapped to `souces` directory user `hr` will be used.
For the database objects mapped to `tests`  directory user `hr_tester` will be used. 
```bash
utplsql run user/pass@db_url \
 -source_path=source -owner=hr \
 -test_path=tests -owner=hr_tester \
 -f=ut_coverage_html_reporter -o=coverage.html \
 -f=ut_sonar_test_reporter -o=test_results.xml
```  

##### Custom mapping of object-types

By default, when mapping project-filed to database objects, utPLSQL will identify object type by file extension.

Below table represents the default mapping of file extensions to database object types.  
| file extension | object type |
| -------------- | ----------- | 
| tpb | type body | 
| pkb | package body | 
| bdy | package body | 
| trg | trigger | 
| fnc | function | 
| prc | procedure | 

If your project naming convention differs and your file extensions do not match the above, or you simply name all of your files wiht `.sql` suffix, you can still use utPLSQL, but you need to provide custom mapping for object types.


Example: Multi-schema project with separate directories for each object owner and object type
```
C:
  \my_project
    \sources
      \hr
        \spec
          \manage_employees.sql
        \body
          \manage_employees.sql
        \type
          \employee_typ.sql
        \type_body
          \employee_typ.sql
        \trigger
          \employees_after_each.sql
    \tests
      \hr
        \spec
          \test_manage_employees.sql
        \body
          \test_manage_employees.sql
```


```bash
utplsql run user/pass@db_url \
 -source_path=source \
 -regex_expression="/(\w+)/(\w+)/(\w+)\..{3}$" \
 -type_mapping="body=PACKAGE BODY/type_body=TYPE BODY/trigger=TRIGGER" \
 -owner_subexpression=1 \
 -name_subexpression=3 \
 -type_subexpression=2 \
 -test_path=tests -regex_expression="/(\w+)/(\w+)/(\w+)\..{3}$" \
 -type_mapping="body=PACKAGE BODY/type_body=TYPE BODY/trigger=TRIGGER" \
 -owner_subexpression=1 \
 -name_subexpression=3 \
 -type_subexpression=2 \
 -f=ut_coverage_html_reporter -o=coverage.html \
 -f=ut_sonar_test_reporter -o=test_results.xml
```

The parameter `type_mapping` accepts a list of a key-value pairs representing mapping of regex subexpression to database object type.  

To better understand the regular expression used, have a look [here](https://regex101.com/r/Vd97v0/1).

#### Object-file mapping rules

In order to allow deterministic and accurate mapping of database source-code into project files, the project directory and file structure needs to meet certain criteria.  
- Source code is kept separate from test code (separate directories)
- Each database (source-code) object is stored in individual file. Package/type specification is kept separate from it's body.
- File name (file path) contains name of database object 
- Each file-path clearly identifies object type (by file extension)
- Each file contains representation of database object "as is". No extra commands (like `set echo off` `ALTER SESSION SET PLSQL_CCFLAGS = 'debug:TRUE';`) or blank lines are present before `CREATE TYPE`,`CREATE TYPE` etc. 
- When project is spanning across multiple database schemes, each file-path clearly and uniformly identifies object owner
 
   
---------------------------------------------------------------------------

----- TODO - continue documentation update from here

----- TODO - verify examples

----- TODO - update images

---------------------------------------------------------------------------

**Reporting using externally provided file mapping**
One of ways to perform coverage reporting on your project files is to provide to the coverage reporter a list of file path/names along with mapping to corresponding object name and object type.

Example:
```sql
begin
  ut.run(
    'usr', 
    ut_coverage_html_reporter(),
    a_source_file_mappings => 
      ut_file_mappings(
        ut_file_mapping(
          file_name    => 'sources/hr/award_bonus.prc',
          object_owner => 'USR',
          object_name  => 'AWARD_BONUS',
          object_type  => 'PROCEDURE'                        
        ),
        ut_file_mapping(
          file_name    => 'sources/hr/betwnstr.fnc',
          object_owner => 'USR',
          object_name  => 'BETWNSTR',
          object_type  => 'FUNCTION'                        
        )
      )
  );
end;
```

Executes all tests in schema `usr` and reports coverage for that execution on procedure `award_bonus` and function `betwnstr`. The coverage report is mapped-back to file-system object names with paths.

**Reporting using regex file mapping rule**
If file names and paths in your project follow a well established naming conventions, 
then you can use the predefined rule for mapping file names to object names or you can define your own rule and pass it to the coverage reporter at runtime.

Example of running with predefined regex mapping rule.
```sql
begin
  ut.run(
    'usr', 
    ut_coverage_html_reporter(),
    a_source_files => ut_varchar2_list('sources/hr.award_bonus.prc','sources/hr.betwnstr.fnc')
  );
end;
```

The predefined rule is based on the following default values for parameters:
* `a_regex_pattern => '/((\w+)\.)?(\w+)\.(\w{3})$'` 
* `a_object_owner_subexpression => 2`
* `a_object_name_subexpression => 3`
* `a_object_type_subexpression => 4`
* `a_file_to_object_type_mapping` - defined in table below

The predefined file extension to object type mappings

| file extension | object type |
| -------------- | ----------- | 
| tpb | type body | 
| pkb | package body | 
| bdy | package body | 
| trg | trigger | 
| fnc | function | 
| prc | procedure | 

Since package specification and type specifications are not considered by coverage, the file extensions for those objects  are not included in the mapping.

Examples of filename paths that will be mapped correctly using predefined rules.
* `[...]directory[/subdirectory[/...]]/object_name.(tpb|pkb|trg|fnc|prc)`
* `[...]directory[/subdirectory[/...]]/schema_name.object_name.(tpb|pkb|trg|fnc|prc)`
* `[...]directory[\subdirectory[\...]]\object_name.(tpb|pkb|trg|fnc|prc)`
* `[...]directory[\subdirectory[\...]]\schema_name.object_name.(tpb|pkb|trg|fnc|prc)`

If file names in your project structure are not prefixed with schema name (like above), the coverage report will look for objects to match the file names in the `current schema` of the connection that was used to execute tests with coverage.

If your project structure is different, you may define your own mapping rule using regex.

Example:
```sql
begin
  ut.run(
    'usr', 
    ut_coverage_html_reporter(),
    ut_file_mapper.build_file_mappings(
      a_file_paths  => ut_varchar2_list('sources/hr/procedures/award_bonus.sql','sources/hr/functions/betwnstr.sql'),
      a_regex_pattern => '.*(\\|\/)(\w+)\.(\w+)\.(\w{3})',
      a_object_owner_subexpression => 2,
      a_object_type_subexpression => 3,
      a_object_name_subexpression => 4,
      a_file_to_object_type_mapping => ut_key_value_pairs(
        ut_key_value_pair('functions', 'function'),
        ut_key_value_pair('procedures', 'procedure')
      )
    )
  );
end;
```
 
